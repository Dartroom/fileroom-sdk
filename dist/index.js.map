{"version":3,"sources":["../src/net/fetchHttpClient.ts","../src/net/defaultRequestOptions.ts","../src/functions/propagateErrors.ts","../src/functions/genUUID.ts","../src/functions/tusUtils.ts","../src/functions/createObjectTemplate.ts","../src/functions/classifyFile.ts","../src/functions/connectWs.ts","../src/functions/timeout.ts","../src/functions/sleep.ts","../src/functions/generateApiKey.ts","../src/net/httpClient.ts","../src/api/baseApi.ts","../src/api/users/index.ts","../src/api/ipfs/index.ts","../src/api/upload/index.ts","../src/api/files/index.ts","../src/client.ts"],"names":["isBrowser","mime","event"],"mappings":"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","sourcesContent":["// source:github.com/strip/stripe-node;\r\nimport fetch from 'cross-fetch';\r\nimport { TestOpts, ProdOpts, BetaOpts } from './defaultRequestOptions';\r\nimport { isBrowser } from 'browser-or-node';\r\nimport { RequestData, RequestHeaders, ResponseHeaders } from '../types';\r\nimport { Timeout, TimeoutTracker } from '../functions';\r\nimport {\r\n  HttpClientInterface,\r\n  HttpClientResponseInterface,\r\n  ConfigOptions,\r\n  RequestOptions,\r\n} from '../interfaces';\r\nimport { HttpClient, HttpClientResponse } from './httpClient';\r\n\r\nexport class FetchHttpClient extends HttpClient implements HttpClientInterface {\r\n  private _fetch: typeof fetch;\r\n  _Headers: RequestHeaders = {};\r\n  readonly _config?: ConfigOptions;\r\n  readonly _requestOpts?: RequestOptions;\r\n  public readonly _isLegacyBrowser: boolean = false;\r\n\r\n  constructor(config?: ConfigOptions) {\r\n    super();\r\n\r\n    // if the Fetch API is not available in legacy browsers,  we need to use a polyfill from cross-fetch else use the native fetch(on the window object)\r\n    this._fetch = isBrowser ? window.fetch || fetch : fetch;\r\n\r\n    this._isLegacyBrowser = isBrowser && !window.fetch;\r\n\r\n    if (config) {\r\n      let headers = {\r\n        Authorization: `${\r\n          config.accessToken && config.accessToken.length > 0\r\n            ? 'Bearer ' + config.accessToken\r\n            : ''\r\n        }`,\r\n      } as RequestHeaders;\r\n\r\n      this._config = config;\r\n      this._Headers = headers;\r\n      switch (config.env) {\r\n        case 'test':\r\n          this._requestOpts = TestOpts;\r\n          break;\r\n        case 'beta':\r\n          this._requestOpts = BetaOpts;\r\n        default:\r\n          this._requestOpts = ProdOpts;\r\n      }\r\n    }\r\n  }\r\n  /** update the acessToken */\r\n  setToken(token: string) {\r\n    if (this._config) {\r\n      this._config.accessToken = token;\r\n      //set Authorization header\r\n      this._Headers = {\r\n        ...this._Headers,\r\n        Authorization: `Bearer ${token}`,\r\n      } as RequestHeaders;\r\n    }\r\n  }\r\n\r\n  /** Extends the currents of the FetchHttpClient\r\n   *\r\n   * @param headers\r\n   */\r\n  extendHeaders(headers: RequestHeaders) {\r\n    this._Headers = { ...this._Headers, ...headers } as RequestHeaders;\r\n  }\r\n\r\n  /**override */\r\n  getClientName(): string {\r\n    return 'fetch';\r\n  }\r\n  /** Use either our dev enviroment or production to make requests\r\n   *\r\n   * @param path\r\n   * @param method\r\n   * @param body\r\n   * @returns\r\n   */\r\n  makeRequestwithDefault(\r\n    path: string,\r\n    method: string,\r\n    body?: RequestData | undefined,\r\n  ): Promise<HttpClientResponseInterface> {\r\n    if (!this._requestOpts) {\r\n      throw new Error('Config is required');\r\n    }\r\n\r\n    let { host, port, protocol, timeout } = this._requestOpts;\r\n    port = port ? port.toString() : '';\r\n    return this.makeRequest(\r\n      host,\r\n      port,\r\n      path,\r\n      method,\r\n      this._Headers,\r\n      body,\r\n      protocol,\r\n      timeout,\r\n    );\r\n  }\r\n  /** Make a request\r\n   *\r\n   * @param host\r\n   * @param port\r\n   * @param path\r\n   * @param method\r\n   * @param headers\r\n   * @param requestData\r\n   * @param protocol\r\n   * @param timeout\r\n   * @returns\r\n   */\r\n  makeRequest(\r\n    host: string,\r\n    port: string,\r\n    path: string,\r\n    method: string,\r\n    headers: RequestHeaders,\r\n    requestData: RequestData | undefined,\r\n    protocol: string,\r\n    timeout: number,\r\n  ): Promise<HttpClientResponseInterface> {\r\n    const Secure = protocol === 'https';\r\n    const url = new URL(path, `${Secure ? 'https' : 'http'}://${host}:${port}`);\r\n    url.port = port;\r\n\r\n    const fetchFn = this._fetch;\r\n\r\n    const methodHasPayload =\r\n      method == 'POST' || method == 'PUT' || method == 'PATCH';\r\n    const body = requestData || (methodHasPayload ? '' : undefined);\r\n\r\n    let options: any = {\r\n      method,\r\n      headers,\r\n    };\r\n\r\n    if (body) {\r\n      options.body = new URLSearchParams(body);\r\n    }\r\n\r\n    const fetchPromise = fetchFn(url.toString(), options);\r\n\r\n    // The Fetch API does not support passing in a timeout natively, so a\r\n    // timeout promise is constructed to race against the fetch and preempt the\r\n    // request, simulating a timeout.\r\n    //\r\n    // This timeout behavior differs from Node:\r\n    // - Fetch uses a single timeout for the entire length of the request.\r\n    // - Node is more fine-grained and resets the timeout after each stage of\r\n    //   the request.\r\n    //\r\n    // As an example, if the timeout is set to 30s and the connection takes 20s\r\n    // to be established followed by 20s for the body, Fetch would timeout but\r\n    // Node would not. The more fine-grained timeout cannot be implemented with\r\n    // fetch.\r\n\r\n    return Promise.race([fetchPromise, Timeout(timeout)])\r\n      .then(res => {\r\n        return new FetchHttpClientResponse(res as Response);\r\n      })\r\n      .finally(() => {\r\n        if (TimeoutTracker.timeout) {\r\n          clearTimeout(TimeoutTracker.timeout);\r\n        }\r\n      });\r\n  }\r\n}\r\n\r\nexport class FetchHttpClientResponse\r\n  extends HttpClientResponse\r\n  implements HttpClientResponseInterface\r\n{\r\n  _res: Response;\r\n\r\n  constructor(res: Response) {\r\n    super(\r\n      res.status,\r\n      FetchHttpClientResponse._transformHeadersToObject(res.headers),\r\n    );\r\n    this._res = res;\r\n  }\r\n\r\n  getRawResponse(): Response {\r\n    return this._res;\r\n  }\r\n\r\n  toStream(\r\n    streamCompleteCallback: () => void,\r\n  ): ReadableStream<Uint8Array> | null {\r\n    // Unfortunately `fetch` does not have event handlers for when the stream is\r\n    // completely read. We therefore invoke the streamCompleteCallback right\r\n    // away. This callback emits a response event with metadata and completes\r\n    // metrics, so it's ok to do this without waiting for the stream to be\r\n    // completely read.\r\n    streamCompleteCallback();\r\n\r\n    // Fetch's `body` property is expected to be a readable stream of the body.\r\n    return this._res.body;\r\n  }\r\n\r\n  toJSON(): Promise<any> {\r\n    return this._res.json();\r\n  }\r\n\r\n  static _transformHeadersToObject(headers: Headers): ResponseHeaders {\r\n    // Fetch uses a Headers instance so this must be converted to a barebones\r\n    // JS object to meet the HttpClient interface.\r\n    const headersObj: ResponseHeaders = {};\r\n\r\n    for (const entry of headers) {\r\n      if (!Array.isArray(entry) || entry.length != 2) {\r\n        throw new Error(\r\n          'Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.',\r\n        );\r\n      }\r\n\r\n      headersObj[entry[0]] = entry[1];\r\n    }\r\n\r\n    return headersObj;\r\n  }\r\n}\r\n","import { RequestOptions } from '../interfaces';\r\n\r\nexport const TestOpts: RequestOptions = {\r\n  host: 'localhost',\r\n  port: 3001,\r\n  protocol: 'http',\r\n  path: '/',\r\n  timeout: 60000,\r\n};\r\n\r\nexport const ProdOpts: RequestOptions = {\r\n  host: 'beta-ams-1.fileroom.app',\r\n  path: '/',\r\n  protocol: 'https',\r\n  timeout: 120000,\r\n};\r\n\r\nexport const BetaOpts: RequestOptions = {\r\n  host: 'beta.fileroom.app',  \r\n  path: '/',\r\n  protocol: 'https',\r\n  timeout: 120000,\r\n};","export function propagateErrors(json: any) {\r\n  if (json && json.errors) {\r\n    let error = json.errors[0];\r\n    let status = (error.status as number) || 404;\r\n    let message = error.message;\r\n\r\n    throw new Error('API_ERROR: ' + status + ' ' + 'reason: ' + message);\r\n  }\r\n}\r\n","export const generateUUID = (a = '') =>\r\n  a\r\n    ? /* eslint-disable no-bitwise */\r\n      ((Number(a) ^ (Math.random() * 16)) >> (Number(a) / 4)).toString(16)\r\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID);\r\n","import { SocketData } from '../types';\r\n\r\nexport function incrementGlobalProgress(target: Record<string, any>) {\r\n  // increment global progress;\r\n  let values = Object.values(target).filter(\r\n    v => v && v.hasOwnProperty('progress'),\r\n  );\r\n\r\n  let total = values.length * 100;\r\n\r\n  let overall =\r\n    (values.reduce((a, b) => a + Number(b.progress), 0) / total) * 100;\r\n  overall = Number.isNaN(overall) ? 0 : Number(overall.toFixed(2));\r\n\r\n  target.overallProgress = overall;\r\n}\r\n/** Proxy handler for the progressMap */\r\nexport const proxyHandler = {\r\n  set(target: any, prop: string, value: any) {\r\n    //console.log(typeof value, value)\r\n    // if the target doesn't has the property, add with default value {progress:0};\r\n\r\n    const hasProgress =\r\n      typeof value === 'object' && Reflect.has(value, 'progress');\r\n    const hasPercent =\r\n      hasProgress &&\r\n      typeof value.progress === 'object' &&\r\n      Reflect.has(value['progress'], 'percent');\r\n    //console.log(`${prop}: ${hasProgress}`, value)\r\n    // prop is should be defined;\r\n    try {\r\n      if (target[prop] && !target[prop]['jobs']) {\r\n        target[prop].used = true;\r\n        target[prop].jobs = new Map();\r\n      }\r\n      if (hasProgress) {\r\n        if (hasPercent) {\r\n          target[prop].used = true;\r\n          target[prop].jobs.set(value.progress.job, value.progress.percent);\r\n          let jobs = target[prop].jobs;\r\n          let expectedStage = target[prop].expectedStage;\r\n          target[prop].progress =\r\n            ([...jobs.values()].reduce((a, b) => a + Number(b), 0) /\r\n              (expectedStage * 100)) *\r\n            100;\r\n\r\n          let result = value.result || value.progress?.result;\r\n          if (result) {\r\n            target[prop].result = result;\r\n          }\r\n\r\n          incrementGlobalProgress(target);\r\n          return true;\r\n        }\r\n        // just set the target property;\r\n\r\n        let v = target[prop];\r\n        target[prop] = { ...v, ...value };\r\n        target[prop].used = true;\r\n\r\n        incrementGlobalProgress(target); // increment overall progress\r\n        return true;\r\n      } else {\r\n        // got here\r\n        let v = target[prop];\r\n        let val = value.progress || value;\r\n        target[prop] = { ...v, ...val };\r\n\r\n        target[prop].used = true;\r\n\r\n        target[prop].progress = 100;\r\n        incrementGlobalProgress(target); // increment overall progress\r\n        return true;\r\n      }\r\n    } catch (error) {\r\n      return true;\r\n    }\r\n  },\r\n};\r\n","/** create an object template for progress-aggregation proxy\r\n *\r\n * @param {number} sizes\r\n * @param {\"image\"|'animation'|'video'} fileType\r\n * @return {{stage:string,expectedStage:number}}\r\n */\r\nexport function createObjTemplate(\r\n  sizes: number,\r\n  fileType: string,\r\n  duplicate = false,\r\n) {\r\n  if (fileType === 'video') {\r\n    let obj = {\r\n      'Tus Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n      'InterFs Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: sizes + 1,\r\n        jobs: new Map(),\r\n      },\r\n      'InterFs Download': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: sizes + 1,\r\n        jobs: new Map(),\r\n      },\r\n      'Ipfs Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: sizes,\r\n        jobs: new Map(),\r\n      },\r\n      'Original Processed': {\r\n        progress: 100,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n      'Preview Completed': {\r\n        progress: 100,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n      'Video Transcode': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: sizes,\r\n        jobs: new Map(),\r\n      },\r\n      'CDN Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: sizes,\r\n        jobs: new Map(),\r\n      },\r\n    };\r\n    return duplicate\r\n      ? {\r\n          'Tus Upload': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n          'Original Processed': {\r\n            progress: 100,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n        }\r\n      : sizes === 0\r\n      ? {\r\n          'Tus Upload': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n          'InterFs Upload': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: sizes + 1,\r\n            jobs: new Map(),\r\n          },\r\n\r\n          'InterFs Download': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: sizes + 1,\r\n            jobs: new Map(),\r\n          },\r\n          'Original Processed': {\r\n            progress: 100,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n        }\r\n      : obj;\r\n  }\r\n\r\n  if (fileType === 'image' || fileType === 'animation') {\r\n    let obj = {\r\n      'Tus Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n      'Ipfs Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 2,\r\n        jobs: new Map(),\r\n      },\r\n\r\n      'CDN Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n\r\n      'Preview Completed': {\r\n        progress: 100,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n    };\r\n    return sizes === 0\r\n      ? {\r\n          'Tus Upload': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n          'Ipfs Upload': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: sizes + 1,\r\n            jobs: new Map(),\r\n          },\r\n\r\n          'Preview Completed': {\r\n            progress: 100,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n        }\r\n      : obj;\r\n  }\r\n  if (fileType === 'any') {\r\n    let obj = {\r\n      'Tus Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n      'Ipfs Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n\r\n      'CDN Upload': {\r\n        progress: 0,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n\r\n      'Preview Completed': {\r\n        progress: 100,\r\n        used: false,\r\n        expectedStage: 1,\r\n        jobs: new Map(),\r\n      },\r\n    };\r\n    return duplicate\r\n      ? {\r\n          'Tus Upload': {\r\n            progress: 0,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n\r\n          'Preview Completed': {\r\n            progress: 100,\r\n            used: false,\r\n            expectedStage: 1,\r\n            jobs: new Map(),\r\n          },\r\n        }\r\n      : obj;\r\n  }\r\n\r\n  return {};\r\n}\r\n","import { FileType } from '../enums';\r\n\r\n/** \r\n * classifies a file according our specifications for resizing. (**FileType**)\r\n *@param {mimeType} mimeType  the mime type of the file\r\n *@returns {string} -  FileType.IMAGE or others\r\n\r\n */\r\nexport function classifyFile(file: { mimetype: string }): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    let fileFormat = file.mimetype.split('/')[1] as string;\r\n    // use a regExp instead of a switch statements to make it compatible and readable.\r\n    let supportedAudio =\r\n      /(mpeg)|(mp3)|(mp4)|(ogg)|(wav)|(webm)|(flac)|(aac)|(weba)|(amr)|(opus)|(m4a)|(oga)/g;\r\n    // ACC audio -> acc\r\n\r\n\r\n     \r\n    if (\r\n      file.mimetype === 'image/png' ||\r\n      file.mimetype === 'image/jpg' ||\r\n      file.mimetype === 'image/jpeg' ||\r\n      file.mimetype === 'image/webp' ||\r\n      file.mimetype === 'image/avif' ||\r\n      file.mimetype === 'image/tiff'\r\n    ) {\r\n      resolve(FileType.IMAGE);\r\n    } else if (\r\n      file.mimetype === 'image/gif' ||\r\n      file.mimetype === 'image/webp'\r\n    ) {\r\n      resolve(FileType.ANIMATION);\r\n    } else if (file.mimetype === 'video/mp4') {\r\n      resolve(FileType.VIDEO);\r\n    } else if (\r\n      (file.mimetype.includes('audio') && supportedAudio.test(fileFormat)) ||\r\n      (file.mimetype.includes('application/') &&\r\n        ['pdf', 'json'].includes(fileFormat)) ||\r\n      file.mimetype === 'image/svg+xml'\r\n    ) {\r\n      resolve(FileType.ANY);\r\n    } else {\r\n      reject(FileType.UNSUPPORTED);\r\n    }\r\n  });\r\n}\r\n","import WebSocket from 'isomorphic-ws';\r\nexport async function connectWS(url: string): Promise<WebSocket> {\r\n  return new Promise(function (resolve, reject) {\r\n    var server = new WebSocket(url);\r\n\r\n    server.onopen = () => {\r\n      resolve(server);\r\n    };\r\n\r\n    const interval = setInterval(() => {\r\n      if (server.readyState !== 1) {\r\n        return;\r\n      }\r\n\r\n      server.send('ping');\r\n    }, 3000);\r\n\r\n    server.onerror = (err: any) => {\r\n      clearInterval(interval);\r\n      reject(err);\r\n    };\r\n\r\n    server.onclose = () => {\r\n      clearInterval(interval);\r\n    };\r\n  });\r\n}\r\n","export const TimeoutTracker: {\r\n  timeout: NodeJS.Timeout | null;\r\n} = {\r\n  timeout: null,\r\n};\r\nexport const Timeout = (num: number) =>\r\n  new Promise((resolve, reject) => {\r\n    TimeoutTracker.timeout = setTimeout(() => {\r\n      TimeoutTracker.timeout = null;\r\n      reject(new Error('Request timed out'));\r\n    }, num);\r\n  });\r\n","/**\r\n * Pauses execution for the given number of milliseconds.\r\n *\r\n * @param ms - The number of milliseconds to pause for.\r\n * @returns A Promise that resolves after the given number of milliseconds.\r\n */\r\nexport function sleep(ms: number) {\r\n  if (ms < 0) throw new Error('ms must be a positive number');\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import crypto from 'crypto';\r\n\r\n\r\nexport  function generateApiKey() {\r\n  return crypto.randomBytes(20).toString('hex');\r\n}\r\n","// source:github.com/strip/stripe-node;\r\nimport {\r\n  RequestData,\r\n  RequestHeaders,\r\n  ResponseHeaders,\r\n  TimeoutError,\r\n} from '../types';\r\nimport {\r\n  HttpClientInterface,\r\n  HttpClientResponseInterface,\r\n} from '../interfaces';\r\n/**\r\n * Encapsulates the logic for issuing a request to the our API.\r\n *\r\n * A custom HTTP client should should implement:\r\n * 1. A response class which extends HttpClientResponse and wraps around their\r\n *    own internal representation of a response.\r\n * 2. A client class which extends HttpClient and implements all methods,\r\n *    returning their own response class when making requests.\r\n */\r\nexport class HttpClient implements HttpClientInterface {\r\n  static CONNECTION_CLOSED_ERROR_CODES: string[];\r\n  static TIMEOUT_ERROR_CODE: string;\r\n\r\n  /** The client name used for diagnostics. */\r\n  getClientName(): string {\r\n    throw new Error('getClientName not implemented.');\r\n  }\r\n\r\n  makeRequest(\r\n    host: string,\r\n    port: string,\r\n    path: string,\r\n    method: string,\r\n    headers: RequestHeaders,\r\n    requestData: RequestData,\r\n    protocol: string,\r\n    timeout: number,\r\n  ): Promise<HttpClientResponseInterface> {\r\n    throw new Error('makeRequest not implemented.');\r\n  }\r\n\r\n  /** Helper to make a consistent timeout error across implementations. */\r\n  static makeTimeoutError(): TimeoutError {\r\n    const timeoutErr: TimeoutError = new TypeError(\r\n      HttpClient.TIMEOUT_ERROR_CODE,\r\n    );\r\n    timeoutErr.code = HttpClient.TIMEOUT_ERROR_CODE;\r\n    return timeoutErr;\r\n  }\r\n}\r\n\r\n// Public API accessible via HttpClient\r\nHttpClient.CONNECTION_CLOSED_ERROR_CODES = ['ECONNRESET', 'EPIPE'];\r\nHttpClient.TIMEOUT_ERROR_CODE = 'ETIMEDOUT';\r\n\r\nexport class HttpClientResponse implements HttpClientResponseInterface {\r\n  _statusCode: number;\r\n  _headers: ResponseHeaders;\r\n\r\n  constructor(statusCode: number, headers: ResponseHeaders) {\r\n    this._statusCode = statusCode;\r\n    this._headers = headers;\r\n  }\r\n\r\n  getStatusCode(): number {\r\n    return this._statusCode;\r\n  }\r\n\r\n  getHeaders(): ResponseHeaders {\r\n    return this._headers;\r\n  }\r\n\r\n  getRawResponse(): unknown {\r\n    throw new Error('getRawResponse not implemented.');\r\n  }\r\n\r\n  toStream(streamCompleteCallback: () => void): unknown {\r\n    throw new Error('toStream not implemented.');\r\n  }\r\n\r\n  toJSON(): any {\r\n    throw new Error('toJSON not implemented.');\r\n  }\r\n}\r\n","/** Base class for all controllers */\r\nimport { FetchHttpClient } from '../net/fetchHttpClient';\r\nexport class BaseApi {\r\n  /**create a request builder */\r\n   createHttpRequest: FetchHttpClient;\r\n\r\n  constructor(client: FetchHttpClient) {\r\n    this.createHttpRequest = client;\r\n  }\r\n}\r\n","import { BaseApi } from '../baseApi';\r\nimport {\r\n  createUserOptions,\r\n  updateUserOptions,\r\n  loginOptions,\r\n  createUserResponse,\r\n  updateUserResponse,\r\n  loginResponse,\r\n  validatedTokenResponse,\r\n} from '../../interfaces';\r\nimport { propagateErrors, generateApiKey } from '../../functions';\r\n\r\n/**\r\n *\r\n */\r\nexport class UsersApi extends BaseApi {\r\n  private readonly _path: string = '/user';\r\n\r\n  /** checks the validity of the acessToken\r\n   *\r\n   * @returns void\r\n   */\r\n  public readonly validateToken = async () => {\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      this._path + '/validateToken',\r\n      'POST',\r\n    );\r\n\r\n    let json = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    return json as validatedTokenResponse;\r\n  };\r\n  /** create a new Fileroom User\r\n   *\r\n   * @param data - {createUserOptions}\r\n   * @returns createUserResponse - {data: string | { id: string,token: string}}\r\n   */\r\n  async create(data: createUserOptions): Promise<createUserResponse> {\r\n    if (!data || (data && !Object.keys(data).length))\r\n      throw new TypeError(\r\n        'username, email and password are required or a userId for dartroomUsers',\r\n      );\r\n\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      this._path + '/create',\r\n      'POST',\r\n      data,\r\n    );\r\n    let json = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    return json as createUserResponse;\r\n  }\r\n  /** update a Fileroom User\r\n   *\r\n   * @param data\r\n   * @returns\r\n   */\r\n  async update(data: updateUserOptions): Promise<updateUserResponse> {\r\n    let allowedFields = [\r\n      'addIP',\r\n      'removeIP',\r\n      'addDomain',\r\n      'removeDomain',\r\n      'restrictIPs',\r\n      'restrictDomains',\r\n      'showAll',\r\n      'addApiKey',\r\n      'removeApiKey',\r\n    ];\r\n\r\n    if (!data || (data && !Object.keys(data).length))\r\n      throw new TypeError(\r\n        'at least one of the following fields is required: addIP,removeIP,addDomain,removeDomain,restrictIPs,restrictDomains,showAll',\r\n      );\r\n\r\n    if (!Object.keys(data).every(k => allowedFields.includes(k))) {\r\n      throw new TypeError(\r\n        'at least one of the following fields is required: addIP,removeIP,addDomain,removeDomain,restrictIPs,restrictDomains,showAll',\r\n      );\r\n    }\r\n\r\n    // stringify the addApiKey object\r\n    let payload: any = { ...data };\r\n    if (data.addApiKey) {\r\n      let apiKey = generateApiKey();\r\n      let keyObject = { [data.addApiKey]: apiKey };\r\n\r\n      payload.addApiKey = JSON.stringify(keyObject);\r\n    }\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      this._path + '/update',\r\n      'POST',\r\n      payload,\r\n    );\r\n\r\n    let json = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    return json;\r\n  }\r\n\r\n  /** login dev user with their username and password\r\n   * @param data -  username & password Or a dartroomToken\r\n   * @returns loginResponse - {data:string} - the accessToken\r\n   */\r\n  async login(data: loginOptions): Promise<loginResponse> {\r\n    if (!data || (data && !Object.keys(data).length))\r\n      throw new TypeError(\r\n        'username and password  or dartroomToken is required are  required',\r\n      );\r\n\r\n    if (data.dartroomToken && data.dartroomToken.length > 0) {\r\n      this.createHttpRequest.extendHeaders({\r\n        Authorization: `refresh ${data.dartroomToken}`,\r\n      });\r\n    }\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      this._path + '/login',\r\n      'POST',\r\n      data,\r\n    );\r\n    let json = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    if (json.data) {\r\n      this.createHttpRequest.setToken(json.data);\r\n    }\r\n    return json as loginResponse;\r\n  }\r\n}\r\n","import { BaseApi } from '../baseApi';\r\nimport { StreamResponse } from '../../types';\r\nimport {\r\n  statusResponse,\r\n  LegacybrowserRawResponse,\r\n  getOptions,\r\n  pinOptions,\r\n  pinResponse,\r\n} from '../../interfaces';\r\nimport { isBrowser } from 'browser-or-node';\r\nimport { Stream } from 'stream';\r\nimport { propagateErrors } from '../../functions';\r\n/**\r\n *  IPFS  endpoint for the Fileroom API\r\n */\r\n\r\nexport class IpfsApi extends BaseApi {\r\n  public returnedHeaders: Record<string, string> = {};\r\n  /**check pinning status of the given cid\r\n   * @param {cid} cid\r\n   * @returns {statusResponse} statusResponse\r\n   */\r\n  async status(cid: string) {\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      '/ipfs/status' + '?cid=' + cid,\r\n      'GET',\r\n    );\r\n    let json: any = await response.toJSON();\r\n\r\n    return json as statusResponse;\r\n  }\r\n\r\n  /**\r\n   *  get a file from the gateway\r\n   * @param cid - cid of the file to fetch\r\n   * @param {getOptions} options\r\n   * @returns {{StreamResponse}} StreamResponse\r\n   * */\r\n  async get(cid: string, options?: getOptions): Promise<StreamResponse> {\r\n    if (!cid || (cid && cid.length < 5)) throw new TypeError('cid is required');\r\n    let url = '/ipfs/' + cid;\r\n    if (options && options.origin) {\r\n      this.createHttpRequest.extendHeaders({ Origin: options.origin });\r\n    }\r\n\r\n    if (options && options.size) {\r\n      url = url + '?' + 'size=' + options.size;\r\n    }\r\n\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      url,\r\n      'GET',\r\n    );\r\n    let headers: any = response.getHeaders();\r\n    this.returnedHeaders = headers;\r\n\r\n    let contentType = headers['content-type'];\r\n\r\n    let stream = null;\r\n    if (contentType.includes('application/json')) {\r\n      let json = await response.toJSON();\r\n      propagateErrors(json);\r\n    }\r\n\r\n    /** if its legacy browsers with no fetch support, the response from fetch polyfill doesn't contain a streamable body instead it contains a blob\r\n       so we need to get the blob and convert it to a stream (there is a performance hit here)\r\n    *  see https://caniuse.com/fetch\r\n      */\r\n\r\n    if (this.createHttpRequest._isLegacyBrowser) {\r\n      let raw = (await response.getRawResponse()) as LegacybrowserRawResponse;\r\n      console.log(raw);\r\n\r\n      stream = raw._bodyInit.stream();\r\n\r\n      return stream;\r\n    } else {\r\n      stream = isBrowser\r\n        ? (response.toStream(() => {}) as ReadableStream<Uint8Array>)\r\n        : (response.toStream(() => {}) as Stream);\r\n\r\n      return stream;\r\n    }\r\n  }\r\n  /** import a file by cid, create previews and pin it to our ipfs cluster\r\n   * @param cid\r\n   * @param  options - {resize: string[]} - array of sizes to create previews for given file(image or video)\r\n   */\r\n  async pin(cid: string, options?: pinOptions): Promise<pinResponse> {\r\n    if (!cid || (cid && cid.length < 5)) throw new TypeError('cid is required');\r\n    let url = '/ipfs/pin/' + cid;\r\n\r\n    if (options && options.resize) {\r\n      let resizeParams = new URLSearchParams();\r\n      for (let size of options.resize) resizeParams.append('resize', size);\r\n      url = url + '?' + resizeParams.toString();\r\n    }\r\n\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      url,\r\n      'POST',\r\n    );\r\n\r\n    let json: any = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n\r\n    return json as pinResponse;\r\n  }\r\n}\r\n","import { EventEmitter } from 'ee-ts';\r\nimport { Upload } from 'tus-js-client';\r\nimport mime from 'mime-types';\r\nimport {\r\n  UploadFile,\r\n  ProgressEvent,\r\n  GlobalProgress,\r\n  UploadResult,\r\n  RequestHeaders,\r\n  FileDoc,\r\n} from '../../types';\r\nimport {\r\n  uploadOptions,\r\n  RequestOptions,\r\n  socketEvent,\r\n  UploadListners,\r\n} from '../../interfaces';\r\nimport { isBrowser, isNode } from 'browser-or-node';\r\n\r\nimport { Readable, Stream } from 'stream';\r\nimport { generateUUID, connectWS } from '../../functions';\r\nimport { proxyHandler, createObjTemplate, classifyFile } from '../../functions';\r\nimport WebSocket from 'isomorphic-ws';\r\nimport crypo from 'crypto';\r\nimport { FetchHttpClient } from '../../net/fetchHttpClient';\r\nimport { FilesApi } from '../files';\r\n\r\n/**\r\n * Upload  endpoint for the FilesAPI of the Fileroom API\r\n * @param reqOpts - {host,port,protocol,timeout} \r\n * @param config - {accessToken,env} \r\n * @options - uploadOptions  \r\n * \r\n * @example \r\n * ```js\r\n\r\n  const client = new Client({accessToken: 'your token',env:'test' | 'production' | 'beta'});\r\n\r\n  let readStream = fs.createReadStream('path/to/file');\r\n  // usage with files APi (single file upload)\r\n  let {files} = client;\r\n    let upload = await files.uploadFile(readStream,{\r\n      resize:[1080]\r\n    });\r\n\r\n    upload.on('progress',(progress)=>{\r\n    // get the progress of the upload\r\n    }) \r\n\r\n    upload.on('completed',(result)=>{\r\n    // get the result of the upload\r\n    \r\n    }) \r\n\r\n    upload.on(\"error\",(error)=>{}) // get the error of the upload\r\n\r\n    // usage with upload API (multiple file upload)\r\n\r\n    import {Upload} from 'fileroom-sdk';\r\n\r\n    let upload = new UploadApi(reqOpts,config,options);\r\n\r\n    let files = [file1,file2,file3];\r\n\r\n    for(let file of files){\r\n      await upload.start(file);\r\n    }\r\n\r\n    upload.on(\"globalProgress\",(progress)=>{\r\n      // get the ProgressMap of the uploads\r\n        \r\n    }) \r\n\r\n      upload.on(\"allCompleted\",(results)=>{\r\n      // await for all uploads to complete and get the results\r\n      })\r\n      upload.on(\"error\",(error)=>{}) // get the error of the upload\r\n ```\r\n *\r\n */\r\nexport class UploadApi extends EventEmitter<UploadListners> {\r\n  _path: string = '/upload';\r\n  _url: string = '';\r\n  _uploadOptions: Record<string, string> = {};\r\n  _results: Array<UploadResult> = []; // all collections of results from uploads\r\n\r\n  _headers: RequestHeaders;\r\n  _tus: Upload | null = null;\r\n  _rawUrl = '';\r\n  _socket: WebSocket | null = null;\r\n  _progressMap: Map<string, any> = new Map();\r\n  _isSecure: boolean = false; // if the protocol is https\r\n  _fileID: string = '';\r\n  _uploadCount: number = 0;\r\n  uploads: Record<string, string> = {};\r\n  protected createHttpRequest: FetchHttpClient;\r\n  protected fileApi: FilesApi;\r\n  uploadMultiple: boolean = false;\r\n  messsageCount: number = 0;\r\n  finished = false;\r\n  connections: Array <WebSocket> = [];\r\n\r\n  constructor(\r\n    client: FetchHttpClient,\r\n    options?: uploadOptions,\r\n    multiple = false,\r\n  ) {\r\n    super();\r\n    let reqOpts = client._requestOpts as RequestOptions;\r\n    let { host, port, protocol, timeout } = reqOpts;\r\n    let config = client._config;\r\n    this.createHttpRequest = client;\r\n    this.fileApi = new FilesApi(client);\r\n    this.uploadMultiple = multiple;\r\n    const Secure = protocol === 'https';\r\n    this._isSecure = Secure;\r\n    this._rawUrl = `${Secure ? 'https' : 'http'}://${host}${\r\n      port ? ':' + port : ''\r\n    }`;\r\n    const url = new URL(this._path, this._rawUrl);\r\n    url.port = port as string;\r\n    this._url = url.toString();\r\n    this.createHttpRequest.extendHeaders({\r\n      'X-Forwarded-Proto': Secure ? 'https' : 'http',\r\n    });\r\n    this._headers = this.createHttpRequest._Headers;\r\n    if (options) {\r\n      for (let [key, value] of Object.entries(options)) {\r\n        this._uploadOptions[key] = JSON.stringify(value);\r\n      }\r\n    }\r\n\r\n    // if the file Type is File or Blob, add the file size and type to the metadata (Browser only)\r\n  }\r\n  async start(file: UploadFile, options?: uploadOptions): Promise<UploadApi> {\r\n    if (options) {\r\n      for (let [key, value] of Object.entries(options)) {\r\n        this._uploadOptions[key] = JSON.stringify(value);\r\n      }\r\n    }\r\n    let sha = await this.setfileMeta(file);\r\n    let fileID = generateUUID();\r\n    // overide options on the the class;\r\n\r\n    this._url = this._rawUrl + this._path + '?fileID=' + fileID;\r\n\r\n    // populate progressMap with the fileID\r\n    let mime = this._uploadOptions['filetype'] || '';\r\n    let sizes: string[] = this._uploadOptions['resize']\r\n      ? JSON.parse(this._uploadOptions['resize'])\r\n      : [];\r\n\r\n    let checksum = this._uploadOptions['checksum'] || sha;\r\n\r\n    let fileExists = await this.fileApi.exists(checksum);\r\n    let exists = fileExists.data.exists;\r\n\r\n    let fileType = await classifyFile({ mimetype: mime });\r\n\r\n    let obj = createObjTemplate(sizes.length, fileType, exists);\r\n\r\n    let p = new Proxy(obj, proxyHandler);\r\n    this._progressMap.set(fileID, p);\r\n\r\n    if (this._uploadOptions.hasOwnProperty('name')) {\r\n      this.uploads[fileID] = this._uploadOptions['name'];\r\n    }\r\n\r\n    let wsUrl = this._rawUrl.replace('http', 'ws') + '/file-events/' + fileID;\r\n\r\n    this._socket = await connectWS(wsUrl);\r\n     this.connections.push(this._socket);\r\n    this._socket.onmessage = async (event: any) => {\r\n      let data = event.data;\r\n      this.messsageCount++;\r\n      if (data && data !== 'pong') {\r\n        data = JSON.parse(data) as socketEvent;\r\n        await this.handleWsMessage(data, fileID);\r\n      }\r\n    };\r\n    let upload = new Upload(file, {\r\n      endpoint: this._url,\r\n      metadata: this._uploadOptions,\r\n      headers: this._headers as any,\r\n      retryDelays: [0, 3000, 5000, 10000, 20000],\r\n      removeFingerprintOnSuccess: true,\r\n      chunkSize: 1 * 1024 * 1024,\r\n\r\n      onError: error => {\r\n        this.emit('error', error);\r\n        throw Error;\r\n      },\r\n      onProgress: async (bytesUploaded, bytesTotal) => {\r\n        var percentage = (bytesUploaded / bytesTotal) * 100;\r\n\r\n        let payload: socketEvent = {\r\n          event: 'progress',\r\n          data: {\r\n            progress: {\r\n              percent: Math.round(percentage),\r\n              job: 'original',\r\n            },\r\n            status: 'Tus Upload',\r\n          },\r\n        };\r\n        await this.handleWsMessage(payload, fileID);\r\n      },\r\n      onSuccess: () => {},\r\n    });\r\n    upload.start();\r\n    this._tus = upload;\r\n   \r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * set the file metadata to be uploaded (size and type)\r\n   * @returns boolean - true if the file metadata is set\r\n   */\r\n  async setfileMeta(file: UploadFile) {\r\n    let sha = '';\r\n\r\n    if (\r\n      isBrowser &&\r\n      ((typeof File !== 'undefined' && file instanceof File) ||\r\n        (typeof Blob !== 'undefined' && file instanceof Blob))\r\n    ) {\r\n      this._uploadOptions['filetype'] = file.type;\r\n      // name\r\n      this._uploadOptions['name'] = file.name;\r\n\r\n      this._uploadOptions['size'] = file.size.toString();\r\n\r\n      let hash = crypo.createHash('sha256');\r\n      let stream = await file.stream();\r\n      let reader = stream.getReader();\r\n\r\n      while (true) {\r\n        let { done, value } = await reader.read();\r\n        if (done) break;\r\n        if (value) hash.update(value);\r\n      }\r\n      file = reader;\r\n      let checksum = hash.digest('base64');\r\n      this._uploadOptions['checksum'] = checksum;\r\n      sha = checksum;\r\n    }\r\n\r\n    // if the file Type is ReadableStream, add the file size and type to the metadata (Node only)\r\n\r\n    if (file instanceof Stream) {\r\n      // @ts-ignore\r\n      if (file.hasOwnProperty('path') && file.path) {\r\n        // @ts-ignore\r\n        this._uploadOptions['name'] = file.path;\r\n        // @ts-ignore\r\n        let mimeType = mime.lookup(file.path);\r\n        if (!mimeType) throw new Error('File type not supported');\r\n        this._uploadOptions['filetype'] = mimeType;\r\n      }\r\n\r\n      //name\r\n\r\n      // get the file size\r\n      let size = 0;\r\n      let hash = crypo.createHash('sha256');\r\n      for await (const chunk of file) {\r\n        size += chunk.length;\r\n        hash.update(chunk);\r\n      }\r\n      let checksum = hash.digest('base64');\r\n      this._uploadOptions['checksum'] = checksum;\r\n      this._uploadOptions['size'] = size.toString();\r\n      sha = checksum;\r\n    }\r\n    // wait till upload is comoleted\r\n\r\n    return sha;\r\n  }\r\n  /**\r\n   * Method to handle the websocket messages\r\n   * emits progress, globalProgress, completed, allCompleted\r\n   * @param event\r\n   * @param fileID\r\n   */\r\n  async handleWsMessage(event: socketEvent, fileID: string) {\r\n    let { data } = event;\r\n\r\n    if (data) {\r\n      let status = data.status;\r\n      this._progressMap.get(fileID)[status] = data;\r\n      let result = data.result || data.progress?.result;\r\n\r\n      if (!this.uploadMultiple)\r\n        this.emit('progress', this._progressMap.get(fileID) as ProgressEvent);\r\n\r\n      let Globallisteners = [\r\n        ...this.listeners('globalProgress'),\r\n        ...this.listeners('allCompleted'),\r\n      ];\r\n\r\n      if (!this.uploadMultiple && Globallisteners.length) {\r\n        throw new Error(\r\n          'globalProgress and allCompleted listeners are required for multiple uploads, listen to the completed and progress events instead',\r\n        );\r\n      }\r\n\r\n      let Singlelisteners = [\r\n        ...this.listeners('progress'),\r\n        ...this.listeners('completed'),\r\n      ];\r\n      if (this.uploadMultiple)\r\n        if (Singlelisteners.length) {\r\n          throw new Error(\r\n            'progress and completed listeners are required for single uploads, listen to the globalProgress and allCompleted events instead',\r\n          );\r\n        }\r\n      let totalProgress = 0;\r\n      let expectedSize = [...this._progressMap.keys()].filter(\r\n        event => event !== 'totalProgress',\r\n      ).length;\r\n\r\n      let obj: any = {};\r\n      for (let [key, value] of this._progressMap) {\r\n        let progress = value as ProgressEvent;\r\n        let newKey = this.uploads[key] || key;\r\n        if (newKey) obj[newKey] = value;\r\n        let { overallProgress } = progress;\r\n        if (overallProgress) totalProgress += overallProgress;\r\n      }\r\n\r\n      let percent = (totalProgress / (expectedSize * 100)) * 100;\r\n      this._progressMap.set('totalProgress', Number(percent.toFixed(2)));\r\n\r\n      obj.totalProgress = Number(percent.toFixed(2));\r\n\r\n      this.emit('globalProgress', obj);\r\n\r\n      let completed =\r\n        result && result.hasOwnProperty('file')\r\n          ? result.file\r\n          : (result as FileDoc);\r\n\r\n      if (\r\n        result &&\r\n        completed.expectedPreviewCount === completed.currentPreviewCount\r\n      ) {\r\n        if (this.uploadMultiple) {\r\n          this._results.push(result);\r\n          // when each upload is completed, upload\r\n          this._uploadCount++;\r\n          if (this._uploadCount === this._progressMap.size - 1) {\r\n            this.finished = true;\r\n            this.emit('allCompleted', this._results);\r\n           if(this.finished)  await this.closeConnections();\r\n            // close the socket\r\n          }\r\n        }\r\n\r\n        this.emit('completed', result);\r\n        this.finished = true;\r\n        if (!this.uploadMultiple && this.finished) await this.closeConnections();\r\n        // close the socket after the upload\r\n      }\r\n    }\r\n  }\r\n  async closeConnections() { \r\n    // close the connection\r\n    this.connections.forEach((cons:WebSocket) => {\r\n      cons.close();\r\n     })\r\n  }\r\n  \r\n}\r\n","import { BaseApi } from '../baseApi';\r\nimport {\r\n  listOptions,\r\n  listResponse,\r\n  awaitUploadResponse,\r\n  deleteOneOptions,\r\n  deleteResponse,\r\n  uploadOptions,\r\n  existsResponse,\r\n} from '../../interfaces';\r\nimport { propagateErrors, sleep } from '../../functions';\r\n\r\nimport { UploadApi } from '../upload';\r\nimport { UploadFile, UploadEvents } from '../../types';\r\n\r\n/**\r\n * Files  endpoint of  Fileroom API for:\r\n * - listing files\r\n * - awaiting for uploaded files\r\n * - And  deleting  them\r\n * @example\r\n *\r\n */\r\nexport class FilesApi extends BaseApi {\r\n  public upload: UploadApi | null = null;\r\n  /**\r\n   *  list  a user files\r\n   * @param {listOptions} options\r\n   * @returns {listOptions} listResponse\r\n   */\r\n  async list(options?: listOptions) {\r\n    let url = '/files/list';\r\n    if (options) {\r\n      let listParams = new URLSearchParams();\r\n      for (let [key, value] of Object.entries(options)) {\r\n        listParams.append(key, value);\r\n      }\r\n      url = url + '?' + listParams.toString();\r\n    }\r\n\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      url,\r\n      'GET',\r\n    );\r\n\r\n    let json: any = await response.toJSON();\r\n    propagateErrors(json);\r\n\r\n    return json as listResponse;\r\n  }\r\n  /** Wait for an uploaded or imported file and return its updated record\r\n   *@param {string} id - tracking id of the file\r\n   * @returns {awaitUploadResponse} awaitUploadResponse\r\n   */\r\n  async awaitUpload(id: string) {\r\n    let url = '/await/upload/' + id;\r\n    const response = await this.createHttpRequest.makeRequestwithDefault(\r\n      url,\r\n      'GET',\r\n    );\r\n\r\n    let json: any = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    return json as awaitUploadResponse;\r\n  }\r\n  /**\r\n   * Delete a file and its previews\r\n   * @param  {deleteOneOptions} opts\r\n   * @returns {deleteResponse} deleteResponse\r\n   *\r\n   */\r\n  async deleteOne(opts: deleteOneOptions) {\r\n    if (\r\n      !opts ||\r\n      (opts && !Object.keys(opts).length && (opts.cid || opts.docID))\r\n    )\r\n      throw new TypeError('   cid or docID is required');\r\n\r\n    if (opts.cid && opts.docID)\r\n      throw new TypeError(' cid or docID is required,not both');\r\n\r\n    let response = await this.createHttpRequest.makeRequestwithDefault(\r\n      'delete/one',\r\n      'POST',\r\n      opts,\r\n    );\r\n\r\n    let json: any = await response.toJSON();\r\n    propagateErrors(json);\r\n    return json as deleteResponse;\r\n  }\r\n\r\n  /**\r\n   *  Delete a list of  files and their previews\r\n   * @param cids - list of cids to delete\r\n   * @returns {deleteResponse} - {{data:Record<string,any>}}\r\n   */\r\n\r\n  async deleteMany(cids: string[]) {\r\n    let url = '/delete/many';\r\n    if (!cids || !cids.length) throw new TypeError('cids is required');\r\n\r\n    let cidParams = new URLSearchParams();\r\n    for (let cid of cids) {\r\n      cidParams.append('cid', cid);\r\n    }\r\n    url = url + '?' + cidParams.toString();\r\n\r\n    let response = await this.createHttpRequest.makeRequestwithDefault(\r\n      url,\r\n      'POST',\r\n    );\r\n\r\n    let json: any = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    return json as deleteResponse;\r\n  }\r\n  /**\r\n   * upload a file or an array of files with individual options(array)  or one globaloptions(see uploadOptions)\r\n   * @param {UploadFile} file\r\n   * @param {uploadOptions} options\r\n   * @event  error - when an error occurs\r\n   * @event progress - progressEvents  for when a single file is uploaded\r\n   * @event  complete - when a single file is uploaded and the upload is complete\r\n   * @event  completeAll - when multiple files are uploaded and their upload is complete\r\n   * @event  globalProgress - progressEvents  for when multiple files are uploaded\r\n   * @returns {UploadApi | Array<UploadApi> |undefined} - UploadApi instance\r\n   */\r\n  async uploadFiles(\r\n    files: UploadFile | Array<UploadFile>,\r\n    options?: uploadOptions | Array<uploadOptions>,\r\n  ) {\r\n    if (!arguments.length) throw new TypeError('file(s) is required');\r\n\r\n    let multipleFiles = Array.isArray(files);\r\n    let globalOpts = Array.isArray(options) ? undefined : options;\r\n\r\n    this.upload = new UploadApi(\r\n      this.createHttpRequest,\r\n      globalOpts,\r\n      multipleFiles,\r\n    );\r\n\r\n    try {\r\n      if (!Array.isArray(files)) {\r\n        this.upload = await this.upload.start(files, globalOpts);\r\n        return this.upload;\r\n      }\r\n\r\n      for (let [index, file] of Object.entries(files)) {\r\n        let opts = Array.isArray(options) ? options[Number(index)] : undefined;\r\n        this.upload = await this.upload.start(file, opts);\r\n        // sleep for 200ms\r\n        await sleep(200);\r\n      }\r\n      return this.upload;\r\n    } catch (err) {\r\n      console.error(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Check if a file exists\r\n   * @param search - cid or an integrityhash or OjHash\r\n   * @returns\r\n   */\r\n  async exists(search: string) {\r\n    let url = '/files/exists';\r\n\r\n    if (!search)\r\n      throw new TypeError('cid or an integrityhash or OjHash is required');\r\n\r\n    let searchParams = new URLSearchParams();\r\n    searchParams.append('search', search);\r\n    url = url + '?' + searchParams.toString();\r\n\r\n    let response = await this.createHttpRequest.makeRequestwithDefault(\r\n      url,\r\n      'GET',\r\n    );\r\n\r\n    let json: any = await response.toJSON();\r\n\r\n    propagateErrors(json);\r\n    return json as existsResponse;\r\n  }\r\n}\r\n","import { ConfigOptions } from './interfaces';\r\nimport { FetchHttpClient } from './net/fetchHttpClient';\r\nimport { UsersApi, IpfsApi, FilesApi } from './api/';\r\n\r\n/**\r\n * The main client class\r\n *params: config - default {env:'production'}\r\n * @example ```js \r\n * const client = new Client({accessToken: 'your token',env:'test' | 'production' | 'beta'});\r\n  // import the ipfs and user api\r\n  let {ipfs,user} = client;\r\n\r\n  let result = await user.login({username:'username',password:'password'})\r\n\r\n\r\n  ```\r\n **/\r\nexport class Client {\r\n  public readonly _config: ConfigOptions;\r\n  public readonly __HttpClient: FetchHttpClient;\r\n  public readonly user: UsersApi;\r\n  public readonly ipfs: IpfsApi;\r\n  public readonly files: FilesApi;\r\n\r\n  /**\r\n   *\r\n   * @param config  - {accessToken:string,env:'test' | 'production' | 'beta',timeout?:number}\r\n   */\r\n  constructor(config: ConfigOptions) {\r\n    if (!config) {\r\n      throw new TypeError('Config is required');\r\n    }\r\n    this._config = config;\r\n\r\n    this.__HttpClient = new FetchHttpClient(config);\r\n    this.user = new UsersApi(this.__HttpClient);\r\n    this.ipfs = new IpfsApi(this.__HttpClient);\r\n    this.files = new FilesApi(this.__HttpClient);\r\n    this.checkAuth();\r\n  }\r\n  /**if an acessToken is passed,check it's validity */\r\n  protected async checkAuth() {\r\n    if (this._config.accessToken && this._config.accessToken.length > 0) {\r\n      return this.user.validateToken().then(res => res);\r\n    }\r\n    return;\r\n  }\r\n}\r\n"]}